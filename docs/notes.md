# Notes

Contains some thoughts over the development time of the project.

- Is it worth separating the SCK and RCK lines for the row selection shift registers?
  - They could be tied together, all that needs to be done is to clock once more because the data is behind one clock cycle, but it would save one line to the FPGA.
  - It is absolutely mandatory to separate those lines, there are multiple reasons for this:
    - The output of the shift register will change immediately and this will be also visible on the display. This could be solved by clocking the lines fast enough to shift the data in that it's not perceptible and then to idle the clock for the persistence of vision to kick into effect.
    - It's just one line extra that gives us the freedom for the update routine to be imperceptible even at lower speeds, since we are using just a ribbon cable or fly wires, frequency is heavily limited.
- The small LED board has the IRF4905 P-MOSFET on it, it seems like they are not a good fit, they will be exchanged for the bigger board.
  - They are on there because I ordered them thinking they were a good fit.
  - They work fine but will mess up operating the LEDs at the target voltage/current because the voltage drop changes heavily depending on the current running through it (dependant on how many LEDs are on)
  - Maybe I messed up with the test circuit, I will test again with 32 LEDs for the bigger version when designing that.
- Pullup for logic shifters is 10K which would lead to asymmetrical charge times for the shift registers.
  - See how long it actually takes to charge the lines up with 10K.
- Shift register is CMOS and the inputs have high-impedances so leaving out current limiting resistors.
  - However they are needed for N-MOSFET and P-MOSFET for example (to protect the device that is delivering the current).
  - I think they can be left out if the power supply delivers the current, and not a ÂµC which has output current limitations.
- Pullups for Logic Shifter Drains / Shift Register Inputs are not suitable for the full size board.
  - It seems like it takes a few microseconds to charge up through a 10K, this will be a big problem depending on the video properties. 24fps / 4bpp will need much lower resistor values.
- The small board uses two shift registers for the column selection on purpose even though it could have been implemented with a single one.
  - The only difference to the full size board will be that we are wiring QC to SER from the first to the second register and this only works if the data is present on QC, instead of it only being present in the buffer stage as for example with QH'.
- I think it's worth dividing the memory access, the audio playback, the video playback and the control unit into different modules / entities so they can be interchanged for different implementations such as different memory storages (Flash, SD-Card, USB-Stick) or different codecs.
- The audio and video drivers will be fed through FIFOs and some additional control signals.
- The memory driver does not need a FIFO really.
- Pull all simulations signals to 'U' when they shouldn't be read instead of driving them with '0' for example?
- 'done' was registered in the spi_memory_driver. Is this really necessary? The simulation reacts badly on it, but it should work on hardware?
- Some testbenches could make use of vhdl2008 be pulling out the internal signals as aliases but we're sticking to Vivado's Default for now ('93?)
  - Instead of duplicating the code we simply route the signals outwards, this is ok because none of this will be synthesized so nothing will be wasted.
- I've implemented some ideas for audio codecs which isn't really something that's worth documenting the process of so I'll just implement one and maybe talk about a bit about the other ideas.
- The file header stores the sizes in 4 bytes even though the SPI flash can address at most 3 bytes.
  - This will result in resizing the audio_bytes and video_bytes signal in the control unit to match the 3 bytes address.
- We don't need to save the signature_begin and signature_end in the control unit as they will only be written and read once, it's a waste of flipflops.
- REQUEST_DATA in the control unit only dispatches a request if the read_audio_n_video is set accordingly.
  - This results in one clock cycle loss if for example audio is in order but the audio fifo is full.
  - Then we need to stall for one cycle for the read_audio_n_video signal to change.
  - Technically we could check in the previous state. Does this make sense hardwarewise and timingwise?
- FSM returns to idle when it's done reading audio and video but should only do so when the playback is stopped completely.
- If we calculate the schedule when the modules feed and eat data from the Fifos we could assume some FSM states.
  - Meaning that we for example don't need to check during bit decoding in audio if the Fifo is empty or not.
  - But for safety measures we will still to this, so it's safer when we expand it later down the line to higher quality samples.
  - This is important because the audio and video driver assume the Fifo only to run out **when there is no data left to play**.
- When playing back the 4 bit sample, we are only adding zeroes at the end.
  - We could make it louder by adding almost a bit on it so it maxes out the amplitude.
- CDC_HOLD_COUNT_WIDTH could be calculated more precisely.
  - We are potentially wasting one bit register space.
- The Audio Driver <-> I2S Master machines should never run out of sync that they need a timeout to resync.
- The codec.py calls ffmpeg with the filter `format=gray` instead of `hue=s=0` now. See if that makes a difference down the line.
  - Kept it gray for now since the intermediate files are smaller and will process faster.
- Control/AudioVideoDriver _done signal
  - It is combinational now, is this dangerous? The signal can only change when the state changes so it should work fine. No need to register, right?
- Check if the difference from the expected i2s clock and the actual datasheet clock results in the audio being player slower or faster.
- Do we need to check for reset /= '1' in the frame_buffer?
- The video driver will skew initially by almost up to a full millisecond for the big board, but that is okay, because this skew will not add up over time. The skew increases with resolution but since we don't intend to go higher we can ignore it.
  - However it would be nice to pre-decode the first frame so this skew does not exist.
- Would be nice to structure the project in a way that it's mostly vendor agnostic.
- A future extension of this project could be to port this to a PYNQ board like the PYNQ Z2 for example and to stream the encoded data from the PS to the PL via the DDR.
  - This way the files could be just playbacked from the file system.
- The v2 of the small board performs very well on the ordered pcb. It can drive the board at 2.3 MHz meaning the full board will work fine with so much strobing there will be no flickering left.
  - However the pullups seem very weak, I was able to turn on the high-side switches (=pulling gate low) with my body without being connected to anything while the row selection shift register was floating.
    - This was confirmed, 10k seems to be better without sacrificing switching speeds because the row selection shift registers shift around 1/32 as fast as the row data shift registers.
  - Note: The pullups for the board's buffer inputs were not included when the manufacturing files were dispatched to JLCPCB and were added afterwards. They were installed hacky but it still works fine.
- The fullsize board will be split into two PCBs
  - Otherwise the display PCB will be way too big and have the ICs on the side making it look ugly
  - This way it can be reused for other projects
  - The controller board will be connected via the pin headers
- The v1.0 of the fullsize board has the row data shift registers wired up in a weird way
  - It was an accident when wiring them up to the connectors because the numbers were aligning so well and I didn't pay attention
  - However it's not too bad, this can either be fixed in HDL or more easily just in the codec and placing the samples reverse for every eight pixels. This fix is contained in the codec.py for this one commit as it will be fixed in the next version.
- Vivado truncates the assert report for the phase_accumulator in the tcl window. But the messages window shows it as a whole?
- Theoretically we could bloat up the media header to include detailed codec information so the audio and video driver could handle it accordingly, but the goal of this project is not to build a fully functional and configurable decoder in hdl.
  - The video resolution was included so maybe the video driver could pad the file accordingly.
- The MEDIA_BASE_ADDRESS in the control unit's generics should probably be made a port so we could dynamically select different media files from memory.
  - The main reason this is a generic now is that I only plan to store one file so I don't need to keep reflashing the player bitstream.
- Technically there is no real necessity to write a script to merge the bitfile with an encoded file but since the commands are so radically different for Windows and Linux, it's easier to provide a script.
- PyAudio runs only single-threaded and therefore it's crucial to have minimal latency in the audio callback which feeds the audio buffer.
  - The decode routine is very slow since it's very unoptimized (to showcase the simplicity), so decoding audio while playback causes audible stuttering.
